<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <meta http-equiv="Content-Language" content="es">
    <meta name="generator" content="XEmacs + HTML::Mason + mod_perl">
    <title>Arquitecturas de Altas Prestaciones:Introducción a node.js</title>
    <meta name="AUTHOR" content="Juan Julián Merelo Guervós">
    <meta name="keywords" content="javascript, node.js, restler, npm, js, tutoriales">
    <meta name="description" content="Consumiendo y creando servicios web usando javascript">
   <link href='http://fonts.googleapis.com/css?family=Arvo|Source+Code+Pro' rel='stylesheet' type='text/css'>
  </head>
<style type="text/css" media="all">
body { font-family: 'Arvo', serif; }

code.ejemplo {
  font-size:medium;
  white-space:pre;	
  display: block;
  padding: 2pt;
  background-color: lightYellow;
  color: darkBlue;
  border-style: double;
  border-color: #000080;
  border-width: 2pt;
  font-family:  'Source Code Pro', Courier New, Courier;
  text-indent: 0%;
  margin-right: 5%;
  margin-left: 5%;
}

/* Style definition file generated by highlight 3.8, http://www.andre-simon.de/ */

/* Highlighting theme: Kwrite Editor */

body.hl	{ background-color:#e0eaee; }
pre.hl	{ color:#000000; background-color:#e0eaee; font-size:10pt; font-family:'Courier New';}
.hl.num { color:#b07e00; }
.hl.esc { color:#ff00ff; }
.hl.str { color:#bf0303; }
.hl.pps { color:#818100; }
.hl.slc { color:#838183; font-style:italic; }
.hl.com { color:#838183; font-style:italic; }
.hl.ppc { color:#008200; }
.hl.opt { color:#000000; }
.hl.lin { color:#555555; }
.hl.kwa { color:#000000; font-weight:bold; }
.hl.kwb { color:#0057ae; }
.hl.kwc { color:#000000; font-weight:bold; }
.hl.kwd { color:#010181; }

</style>
<body>
<h1>Introducción a node.js</h1>




<div class="objetivos"> <ul>
	  

	  <li>Conocer node.js y saber sus conceptos fundamentales.</li> 

	  <li>Aprender los conceptos básicos de los servicios web basados en 
REST, la representación de datos usada y cómo implementarlos en node.js</li> 
	  
	  <li>Realizar prototipos rápidos de cliente y servidor de servicio web usando node.js</li>

      </ul>
</div>  


<h2> Node.js, un intérprete asíncrono para JS</h2>



<p>La aceptación de JS como un lenguaje de programación procede del hecho
  de su incorporación en diferentes herramientas de propóxito general,
  y sobre todo de haberlo desgajado del navegador. Una de tales
  herramientas es <a href="http://nodejs.org/">Node.js</a>, un sistema
  para programación de eventos asíncrono que usa como base JS. Se puede usar
  directamente como intérprete de JS (tal como hemos
  hecho <a href="http://geneura.ugr.es/%7Ejmerelo/tutoriales/servicios-web">en este otro tutorial</a>), salvo por el hecho de que
  está preparado para trabajar de forma asíncrona, por lo que un
  patrón habitual de comportamiento, que es asignar la salida de una
  orden a una variable, se convierte aquí en la creación de un
  <em>callback</em>, es decir, de una función a la que se llama una vez que se
  complete la acción que se ha solicitado. No es que sea algo extraño
  dentro del mundo JS, puesto que es la misma forma de trabajar que
  tiene <a href="http://geneura.ugr.es/%7Ejmerelo/asignaturas/AAP/AAP-Javascript-2.mhtml">JQuery</a>.</p>

<p>En todo caso, node.js convierte JS en un lenguaje de propósito
  general, algo que le falta a otros intérpretes como Rhino, que
  necesita usar librerías de Java para poder hacer cosas básicas como
  abrir ficheros. Empecemos pues, por el principio: instalar node.js,
  lo que se puede hacer en Linux fácilmente con <code>sudo apt-get
    install nodejs</code>, desde los repositorios, o
  <a href="http://nodejs.org/download/">descargándoselo desde su
  web</a>. Conviene usar este último método, porque es un lenguaje en
  evolución constante, de forma que los repositorios de Linux van
  siempre un poco por detrás. </p>

<p>Seguimos haciendo nuestro primer programa, 
  un <a href="https://github.com/JJ/curso-js/blob/master/code/guenas.js">programa simple (guenas.js)</a>
  en <code>node.js</code> y ejecutémoslo. </p>
<code class="ejemplo">#<span class="hl sym">!/</span>usr<span class="hl sym">/</span>bin<span class="hl sym">/</span>node

<span class="hl kwa">var</span> saludo <span class="hl sym">=</span> <span class="hl kwa">new</span> Object<span class="hl sym">;</span>
saludo<span class="hl sym">.</span>hola <span class="hl sym">=</span> <span class="hl str">'mundo'</span><span class="hl sym">;</span>
console<span class="hl sym">.</span><span class="hl kwd">log</span><span class="hl sym">(</span> saludo <span class="hl sym">);</span>
</code>
<p>La primera línea es exclusivamente para sistemas Linux (que son,
  por otro lado, los únicos serios para desarrollo de software); en ella
  habrá que poner el camino completo al intérprete de node; este es
  una opción, como <code>/usr/local/bin/node</code>; con ella y
  haciendo ejecutable el fichero con <code>chmod +x node.js</code>
  podemos ejecutarlo y obtener el siguiente resultado</p>
<code class="ejemplo">jmerelo@penny:~/servicios-web/ejemplos$  <span class="user">./guenas.js </span>
{ hola: 'mundo' }
</code>
<p>En otro entorno (o si no se quiere hacer al fichero ejecutable),
  con escribir</p>
<code class="ejemplo">jmerelo@penny:~/servicios-web/ejemplos$  <span class="user">node guenas.js </span></code>
<p>es suficiente. En cualquier caso, la salida será la misma. Y la
  explicación también: definimos un objeto <code>saludo</code> en la primera
  línea, y en la segunda le asignamos el valor <code>mundo</code> a la variable
  de instancia <code>hola</code>, o visto de otro modo, el valor <code>mundo</code> a la
  clave <code>hola</code>. <code>console.log</code> imprime la cadena en la salida,
  escribiendo directamente (y además en JSON) el valor de la
  misma. </p>


<p>Sin embargo, node.js no es un intérprete habitual, tiene una forma
  particular de hacer las cosas: asíncronamente. Veremos, por ejemplo,
  como <a href="http://docs.nodejitsu.com/articles/file-system/how-to-read-files-in-nodejs">leer un fichero</a>, el de las quinielas que 
  hemos usado hasta ahora.</p> 

<code class="ejemplo">#<span class="hl sym">!/</span>usr<span class="hl sym">/</span>local<span class="hl sym">/</span>bin<span class="hl sym">/</span>node

fs <span class="hl sym">=</span> <span class="hl kwd">require</span><span class="hl sym">(</span><span class="hl str">'fs'</span><span class="hl sym">);</span>
fs<span class="hl sym">.</span><span class="hl kwd">readFile</span><span class="hl sym">(</span><span class="hl str">'quiniela.datos'</span><span class="hl sym">,</span> <span class="hl str">'utf8'</span><span class="hl sym">,</span> 
	    <span class="hl kwa">function</span><span class="hl sym">(</span>err<span class="hl sym">,</span>datos<span class="hl sym">) {</span>
		<span class="hl kwa">if</span> <span class="hl sym">(</span>err<span class="hl sym">) {</span>
		    <span class="hl kwa">return</span> console<span class="hl sym">.</span><span class="hl kwd">log</span><span class="hl sym">(</span>err<span class="hl sym">);</span>
		<span class="hl sym">};</span>
		<span class="hl kwa">var</span> filas <span class="hl sym">=</span> datos<span class="hl sym">.</span><span class="hl kwd">split</span><span class="hl sym">(</span><span class="hl str">"</span><span class="hl esc">\n</span><span class="hl str">"</span><span class="hl sym">);</span>
		<span class="hl kwa">for</span> <span class="hl sym">(</span> <span class="hl kwa">var</span> f <span class="hl kwa">in</span> filas <span class="hl sym">) {</span>
		    <span class="hl kwa">var</span> cachos <span class="hl sym">=</span> filas<span class="hl sym">[</span>f<span class="hl sym">].</span><span class="hl kwd">split</span><span class="hl sym">(</span><span class="hl str">" "</span><span class="hl sym">);</span>
		    <span class="hl kwa">var</span> partido <span class="hl sym">= {</span> <span class="hl str">'local'</span><span class="hl sym">:</span> cachos<span class="hl sym">[</span><span class="hl num">0</span><span class="hl sym">],</span>
				    <span class="hl str">'visitante'</span><span class="hl sym">:</span> cachos<span class="hl sym">[</span><span class="hl num">1</span><span class="hl sym">],</span>
				    <span class="hl str">'resultado'</span><span class="hl sym">:</span> cachos<span class="hl sym">[</span><span class="hl num">2</span><span class="hl sym">] };</span>
		    console<span class="hl sym">.</span><span class="hl kwd">log</span><span class="hl sym">(</span> partido <span class="hl sym">);</span>
		<span class="hl sym">}</span>
	    <span class="hl sym">});</span></code>

<p>En este <a href="https://github.com/JJ/curso-js/blob/master/code/lee-quiniela.js">programa</a> (que actúa
  sobre <a href="https://github.com/JJ/curso-js/blob/master/code/quiniela.datos">este fichero de datos</a>) se usa el intérprete node.js, lo que se ve en la
  primera línea, que no hace falta en Windows (aunque se tendrá que
  ejecutar desde línea de órdenes poniendo explícitamente node
  fichero.js).  En la segunda vemos que se carga una librería usando 
  <code>require</code>, el <a href="http://geneura.ugr.es/%7Ejmerelo/asignaturas/AAP/AAP-Taller-1.mhtml#T1:t1:common">mecanismo
  común</a> para cargar un módulo y evaluarlo, que,
  además, crea un objeto que se puede usar; lo usamos más adelante
  para leer un fichero. <a href="http://nodejs.org/api/fs.html"><code>fs</code> se refiere a <em>filesystem</em></a>, o
  sistema de ficheros, y es el módulo que contiene una serie de
  funciones para interaccionar con el mismo. </p>

<p>La siguiente línea es la que usa un modo de actuación propio de
  node.js. Como ya se ha indicado (varias veces), node funciona de
  forma asíncrona. En general, el patrón de las funciones en node, en
  vez de ser
<code class="ejemplo">haz_a();
haz_b();</code>
que ejecutaría <code>haz_a</code>, y, tras terminar, ejecutaría <code>haz_b</code>, es
<code class="ejemplo">haz_a(parametros, haz_b);
haz_c()</code>
que viene a decir ejecuta <code>haz_a</code> sobre unos <code>parametros</code> y, cuando
veas que has terminado, llama a la función <code>haz_b</code>; fijaros que se
trata de un puntero a función, no una llamada a la misma (no lleva paréntesis). Pero dependiendo
de lo que tarde <code>haz_a</code>, <code>haz_c</code> podría ejecutarse antes que
<code>haz_b</code>. En general, la secuencia de las líneas no tiene por qué ser
la secuencia de ejecución de las funciones, eso es precisamente lo que
significa la asincronía. Eso no quiere decir que no se pueda usar como
cualquier otro lenguaje, sólo que hay que tener cuidado. Y, por otro
lado, permite responder muy rápidamente a eventos sin bloquear la
operación; cada evento inicia una hebra y se van procesando en
paralelo.</p>

<p>Vamos a la orden específica: efectivamente, con <code>readFile</code> leemos
  el fichero. Los dos primeros 
  argumentos son el nombre del fichero y, a continuación, la
  codificación, que es obligatorio usar. Y continuación el <em>callback</em>
  del que hemos hablado: una función que se ejecuta cuando se
  termine; se trata de una función anónima tal como las que hemos
  visto en apartados anteriores. El hecho de que se ejecute asíncronamente quiere decir que
  fs.readFile se ejecuta y se deja el evento generado; si hubiera una
  orden a continuación se ejecutaría inmediatamente. Esto le permite a
  <code>node.js</code> leer las cosas con mucha eficiencia, y hacer una serie de
  operaciones que no se pueden hacer fácilmente con otros
  lenguajes.</p>

<p>Concentrémonos en la función. Tiene dos argumentos: <code>err</code> y
  <code>datos</code>. Si hay un error, estará en la primera variable (que
  comprobamos) y si no, el resultado irá a la segunda variable. Es
  decir, cuando se ejecute la acción, se llamará a la función con dos
  argumentos, uno de los cuales será <code>null</code>. Vemos también que se usa
  <code>console.log</code> para escribir en la consola; <code>console</code> es un objeto
  que equivaldría al <code>document</code> del DOM, salvo que no tiene ningún
  tipo de estructura; tiene la ventaja de que si se escribe una
  estructura de datos compleja, la "desplegará". </p>

<p>El resto del programa es más o menos habitual; usamos la clase que
  hemos definido anteriormente para genera un objeto de cada tipo e
  imprimirlo usando <code>console.log</code>. El resultado será más o menos
  así:</p>
<code class="ejemplo">{ local: 'Madrid', visitante: 'Barça', resultado: 'x' }
{ local: 'Atleti', visitante: 'Barça', resultado: '1' }
{ local: 'Athleti', visitante: 'Recre', resultado: '1' }
{ local: 'Depor', visitante: 'Athleti', resultado: '2' }
{ local: 'Elche', visitante: 'Hércules', resultado: 'x' }
{ local: 'Cai', visitante: 'Madrid', resultado: 'x' }
  { local: 'Graná', visitante: 'Recre', resultado: '1' }</code>
<p>Es decir, los datos leídos en formato JSON.</p>






<h2><code>npm</code>, instalación de módulos en Node</h2>



<p><code>fs</code> es sólo el principio de una serie de módulos muy
  interesante; de hecho, es un módulo que se instala por omisión. Hay un módulo para crear servidores web, pero lo
  veremos más adelante (sólo para tener una idea se puede
  visitar <a href="http://nodetuts.com/">nodetuts</a>). En
  el <a href="http://nodejs.org/docs/latest/api/index.html">sitio de
    descarga de nodejs</a> vienen
    también todos los módulos disponibles, que permiten trabajar con el
  sistema operativo y cosas más avanzadas como una interfaz
  criptográfica. Pero si se quieren instalar más módulos, una de las
  características más interesantes de node es que tiene su propio
  gestor de paquetes, <code>npm</code>. Hay que <a href="http://npmjs.org/">seguir
      las instrucciones para instalarlo</a> y una vez hecho tener en
  cuenta que los módulos se instalan por omisión en el directorio
  superior al que uno está
  trabajando. La <a href="https://npmjs.org/">lista
  de todos los paquetes está en línea, y contiene módulos para la
      mayoría de los servicios web y aplicaciones actuales.</a>


</p><p>Instalemos por ejemplo <a href="https://github.com/mikeal/request"><code>request</code></a>, una de las librerías más
  populares, que actúa como cliente de HTTP. Una vez instalado npm, se
  escribe (en el directorio donde lo vayamos a usar, en
  general; la política de módulos de Node es tener los módulos
  instalados junto con la aplicación que los usa, en vez de en un
  sitio centralizado) <code>npm install request</code>. Esta orden, si
  la conexión a Internet está disponible, descargará e instalará el
  módulo en el directorio desde la que la llamemos. Si se ejecuta por
  primera vez, creará un directorio <code>node_modules</code>, dentro del cual
  habrá un directorio <code>request</code>. </p>

<p>Con <code>request</code> podemos codificar todo tipo de peticiones REST. A un
  nivel muy básico se puede usar de la forma siguiente, en el programa
  <a href="https://github.com/JJ/curso-js/blob/master/code/request.js">request.js</a>, que pide la línea
  temporal pública de Twitter:</p>

<code class="ejemplo"><span class="hl kwa">var</span> request <span class="hl sym">=</span> <span class="hl kwd">require</span><span class="hl sym">(</span><span class="hl str">'request'</span><span class="hl sym">);</span>
<span class="hl kwa">var</span> url <span class="hl sym">=</span><span class="hl str">'https://stream.twitter.com/1.1/statuses/sample.json'</span><span class="hl sym">;</span>
<span class="hl kwd">request</span><span class="hl sym">(</span>url<span class="hl sym">,</span> <span class="hl kwa">function</span> <span class="hl sym">(</span>error<span class="hl sym">,</span> response<span class="hl sym">,</span> body<span class="hl sym">) {</span>
  <span class="hl kwa">if</span> <span class="hl sym">(!</span>error <span class="hl sym">&amp;&amp;</span> response<span class="hl sym">.</span>statusCode <span class="hl sym">==</span> <span class="hl num">200</span><span class="hl sym">) {</span>
      console<span class="hl sym">.</span><span class="hl kwd">log</span><span class="hl sym">(</span>JSON<span class="hl sym">.</span><span class="hl kwd">parse</span><span class="hl sym">(</span>body<span class="hl sym">));</span>
  <span class="hl sym">}</span> <span class="hl kwa">else</span> <span class="hl sym">{</span>
      console<span class="hl sym">.</span><span class="hl kwd">log</span><span class="hl sym">(</span>error<span class="hl sym">);</span>
  <span class="hl sym">}</span>
<span class="hl sym">})</span>
</code>

<p>Usamos la librería recién instalada para descargarnos la línea
  temporal de <a href="https://twitter.com/">Twitter</a>, usando la
  librería llamada <code>JSON</code>, que se instala con Node. La forma de
  habitual es la asíncrona habitual en Node: se hace la petición y se
  le pasa la función a la que hay que llamar cuando se reciba la
  respuesta, como en el caso anterior de apertura de un fichero. A la
  función se la llama con tres parámetros: o bien <code>err</code>, en caso de
  que se produzca un error, o bien <code>response</code> y <code>body</code> en caso de que
  la respuesta sea correcta. <code>body</code> contendrá el texto de la
  respuesta, que habrá que decodificar (o imprimir tal cual, en caso
  de que se trate de HTML); <code>response</code> es una estructura de datos
  compleja, que podemos imprimir con <code>console.log</code> (y saldrá un montón
  de cosas, incluyendo la versión de HTTP, las cabeceras, y mucha
  información más), pero que contiene,
  entre otras cosas, el estado de la petición, con un código del
  protocolo HTTP.  En el programa anterior se comprobaba sólo si había
  error o no; ahora demás comprobamos que el código devuelto es el
  correcto, es decir, 200. Si hubiera un código 400, o 500, o incluso
  un 201, tendríamos que interpretar la respuesta de otra forma.</p>






<h2>Usando un servidor web</h2>



<p>Para escribir posibles respuestas a una petición web hay que
  hacerlo desde un servidor. La  tendencia moderna es hacerlo desde un
  entorno integrado, sin embargo los servidores web multifunción
  permiten tanto ofrecer páginas web estáticas como webs dinámicas, y
  además hacerlo desde una variedad de lenguajes de programación; por
  eso conviene conocer, al menos, cómo instalar un servidor web simple
  y hacer programas que funcionen desde él con facilidad. </p>

  <p>El clásico <a href="http://httpd.apache.org/">Apache</a> sigue
  usándose extensivamente, aunque últimamente se están empezando a
  usar otras opciones como el <a href="http://nginx.org/">nginx</a>, un
  servidor web de altas prestaciones que se puede isntalar, además, en
  todo tipo de plataformas (aunque este último no puede ejecutar, de
  forma directa, los CGIs de los que hablamos en este apartado). Tanto uno como otro están disponibles en
    los repositorios de las distribuciones Linux más comunes. </p>

  <p>Un servidor web se instala como un servicio (es decir, un
  programa que se queda ejecutándose en memoria permanentemente) y <em>escucha</em> un
  puerto TCP/IP, normalmente el 80; este puerto, en Linux, está
  reservado (como todos hasta el 999) al superusuario, así que hay que
  ejecutarlo con esos privilegios. Una vez instalado se pueden servir
  tanto páginas estáticas (habrá que consultar en la documentación
  para ver cuál es el directorio configurado para hacerlo) como
  dinámicas (una vez más, también hay que consultar cuál es el
  directorio por omisión). Las páginas estáticas se sirven (más o
  menos) tal cual, y las dinámicas se generan a partir de la ejecución
  de un programa desde el servidor, con los privilegios del mismo o
  los que tenga configurados. Esto lo veremos más adelante, pero la
  idea principal es que los recursos accesibles al servidor web están
  en una serie de directorios cuyo valor lo calcula el servidor a
    partir del URL que se le solicita.</p>

<p>Para servir contenidos desde un programa, la forma habitual es
  copiar el programa con la extensión .cgi al directorio que se haya
  configurado para ello. De la forma más simple posible un CGI escrito
  en node.js podría ser el siguiente:</p> 

<code class="ejemplo"><span class="hl slc">#!/usr/bin/node</span>

<span class="hl kwc">//</span>cabecera
console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">'Content-Type: text/plain; charset=UTF-8'</span><span class="hl opt">);</span>

<span class="hl kwc">//</span>contenido
var una_variable<span class="hl opt">=[</span><span class="hl str">'uno'</span><span class="hl opt">,</span><span class="hl str">'dos'</span><span class="hl opt">,{</span> tres<span class="hl opt">:</span> <span class="hl str">'tres'</span><span class="hl opt">}];</span>
console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">''</span><span class="hl opt">);</span>
console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span>una_variable<span class="hl opt">);</span></code>

<p>Para ejecutarlo no hay más que copiarlo a un directorio determinado
  con permisos de ejecución para otros (<code>chmod +x
    hola-js.cgi</code>).La primera envía una cabecera al cliente que
  le indica el tipo que se usa; la segunda parte es la que
  efectivamente envía el contenido, en este caso una variable en JSON
  (recordad que console.log escribe en salida estándar, y convierte
  las estructuras de datos a JSON).</p> 

<p>Node, por su naturaleza asíncrona, realmente no es el mejor sistema para
  trabajar con JavaScript en un servidor que incluya otros
  lenguajes. Sin embargo, se puede usar Javascript de muchas maneras
  diferentes: <a href="http://www.silkjs.net/">SilkJS</a>, por ejemplo, es
  un intérprete de JS que incluye también un servidor web;
  o <a href="http://code.google.com/p/v8cgi/">V8 CGI</a> es un sistema
  para crear CGIs basado en el intérprete rápido de JS de Google. Por
  no introducir más herramientas, no los vamos a ver aquí, pero
  conviene tener en cuenta que existen este tipo de soluciones que
  pueden convivir en un servidor como Apache o NGINX con otros
  lenguajes como Ruby o Perl.</p>

<h2>node.js como servidor</h2>



<p>Crear un servidor web con node.js es tan simple que viene
  directamente en <a href="http://nodejs.org/">la página principal del
  mismo</a></p>
<code class="ejemplo"><span class="hl kwa">var</span> http<span class="hl sym">=</span><span class="hl kwd">require</span><span class="hl sym">(</span><span class="hl str">'http'</span><span class="hl sym">);</span>
http<span class="hl sym">.</span><span class="hl kwd">createServer</span><span class="hl sym">(</span><span class="hl kwa">function</span> <span class="hl sym">(</span>req<span class="hl sym">,</span> res<span class="hl sym">) {</span>
  res<span class="hl sym">.</span><span class="hl kwd">writeHead</span><span class="hl sym">(</span><span class="hl num">200</span><span class="hl sym">, {</span><span class="hl str">'Content-Type'</span><span class="hl sym">:</span> <span class="hl str">'text/plain'</span><span class="hl sym">});</span>
  res<span class="hl sym">.</span><span class="hl kwd">end</span><span class="hl sym">(</span><span class="hl str">'Ahí estamos</span><span class="hl esc">\n</span><span class="hl str">'</span><span class="hl sym">);</span>
<span class="hl sym">}).</span><span class="hl kwd">listen</span><span class="hl sym">(</span><span class="hl num">8080</span><span class="hl sym">,</span> <span class="hl str">'127.0.0.1'</span><span class="hl sym">);</span>
console<span class="hl sym">.</span><span class="hl kwd">log</span><span class="hl sym">(</span><span class="hl str">'Server running at http://127.0.0.1:8080/'</span><span class="hl sym">);</span>
</code>
  <p>Este <a href="https://github.com/JJ/curso-js/blob/master/code/servidor.js">programa</a> simplemente escribirá "Ahí estamos" en el navegador
  cuando se solicite el URL. Nada complicado, pero tampoco lo es el
  programa: se usa un <a href="http://nodejs.org/api/http.html">módulo
  <code>http</code></a> que es estándar en Node en la primera línea del programa; se crea
  un servidor con <code>createServer</code>. Esta orden recibe como parámetro la
  función a la que hay que llamar cada vez que se reciba una petición.
  Cuando se recibe una petición, se llama a una función
  que escribe primero la cabecera HTTP (<code>writeHead</code>) y termina (<code>end</code>) el
  servicio de la misma escribiendo el contenido que nos aparecerá en
  el navegador.</p>

<p><code>http.createServer</code> crea un objeto y lo devuelve; en este caso, no
  lo asignamos a ninguna variable, sino que sobre el mismo objeto
  (anónimo) le decimos con <code>listen</code> en qué puerto (8080) y dirección (la
  del propio ordenador, <em>there's no place like 127.0.0.1</em>) va a
  escuchar el servidor. Es una orden que se 
  ejecuta de forma asíncrona, con lo que lo que crea es un <em>callback</em>
  que se llamará cada vez que se llame a ese URL. Sólo los puertos por
  encima de 1024 están accesibles al usuario, así que tendréis que
  usar un número en ese rango (como 8080 o 12121, todos por debajo de
  65535). El mensaje se
  escribe en pantalla de forma síncrona, es decir que a partir de que
  se escriba ese mensaje sabremos que podemos usar el servidor.</p>

<p>Evidentemente, si queremos crear un servidor que haga <em>algo</em>
  tendremos que usar las peticiones que se reciban para dar una
  respuesta variable. En el <a href="https://github.com/JJ/curso-js/blob/master/code/servidor-var.js"></a>
<code class="ejemplo"><span class="hl kwa">var</span> http<span class="hl opt">=</span><span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl str">'http'</span><span class="hl opt">);</span> 
http<span class="hl opt">.</span><span class="hl kwd">createServer</span><span class="hl opt">(</span><span class="hl kwa">function</span> <span class="hl opt">(</span>req<span class="hl opt">,</span> res<span class="hl opt">) {</span>
    res<span class="hl opt">.</span><span class="hl kwd">writeHead</span><span class="hl opt">(</span><span class="hl num">200</span><span class="hl opt">, {</span><span class="hl str">'Content-Type'</span><span class="hl opt">:</span> <span class="hl str">'text/plain'</span><span class="hl opt">});</span> 
    res<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(</span><span class="hl str">'Ahí estamos '</span> <span class="hl opt">+</span> req<span class="hl opt">.</span>url<span class="hl opt">);</span> 
<span class="hl opt">}).</span><span class="hl kwd">listen</span><span class="hl opt">(</span><span class="hl num">8081</span><span class="hl opt">,</span> <span class="hl str">'127.0.0.1'</span><span class="hl opt">);</span> 
console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">'Servidor ejecutándose en http://127.0.0.1:8081/'</span><span class="hl opt">);</span></code>
</p><p>La principal diferencia entre este programa y el anterior es,
  aparte del puerto usado (8081 en vez de 8080) la línea en la que
  escribe algo, y en la que usa la variable <code>req</code>, un <a href="http://nodejs.org/api/http.html#http_event_request">objeto</a> que
  contiene información sobre la petición, y entre otras cosas el URL
  (una vez eliminada la parte del servidor) que se ha usado; este URL
  es el que se escribe a continuación de "Ahí estamos", tal cual. </p>

<p>En general, para programar un servicio web habrá que trabajar con
  esa petición (que será la que reciba la orden del API) y actuar
  según la misma, y teniendo en cuenta también la orden HTTP que se
  use (PUT, GET o la que sea). Esto lo veremos un poco más adelante.</p>


<p>A partir de ahí se puede construir un mínimo interfaz REST para
  responder a una serie de peticiones. La idea básica es que las
  funciones a las que tendremos que llamar estarán indentificadas por
  el URL que se use para pedirlas. Por ejemplo, el
  programa <a href="https://github.com/JJ/curso-js/blob/master/code/rest-minimo.js">rest-minimo.js</a></p>

<code class="ejemplo"><span class="hl kwa">var</span> http<span class="hl opt">=</span><span class="hl kwd">require</span><span class="hl opt">(</span><span class="hl str">'http'</span><span class="hl opt">);</span> 
<span class="hl kwa">var</span> puerto<span class="hl opt">=</span>process<span class="hl opt">.</span>argv<span class="hl kwc">[2]</span>?process<span class="hl opt">.</span>argv<span class="hl kwc">[2]</span><span class="hl opt">:</span><span class="hl num">8080</span><span class="hl opt">;</span>
http<span class="hl opt">.</span><span class="hl kwd">createServer</span><span class="hl opt">(</span><span class="hl kwa">function</span> <span class="hl opt">(</span>req<span class="hl opt">,</span> res<span class="hl opt">) {</span> 
    res<span class="hl opt">.</span><span class="hl kwd">writeHead</span><span class="hl opt">(</span><span class="hl num">200</span><span class="hl opt">, {</span><span class="hl str">'Content-Type'</span><span class="hl opt">:</span> <span class="hl str">'text/plain'</span><span class="hl opt">});</span> 
    <span class="hl kwa">var</span> split_url<span class="hl opt">=</span>req<span class="hl opt">.</span>url<span class="hl opt">.</span><span class="hl kwd">split</span><span class="hl opt">(</span><span class="hl str">"/"</span><span class="hl opt">);</span> 
    <span class="hl kwa">if</span> <span class="hl opt">(</span> split_url<span class="hl kwc">[1]</span> <span class="hl opt">==</span> <span class="hl str">''</span> <span class="hl opt">) {</span> 
	res<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(</span><span class="hl str">'Portada'</span><span class="hl opt">);</span> 
    <span class="hl opt">}</span> <span class="hl kwa">else if</span> <span class="hl opt">(</span> split_url<span class="hl kwc">[1]</span> <span class="hl opt">==</span> <span class="hl str">'proc'</span> <span class="hl opt">) {</span> 
	res<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(</span><span class="hl str">'No es la portada'</span><span class="hl opt">);</span> 
    <span class="hl opt">}</span> <span class="hl kwa">else</span> <span class="hl opt">{</span> 
	res<span class="hl opt">.</span><span class="hl kwd">end</span><span class="hl opt">(</span><span class="hl str">'No entiendo la petición'</span><span class="hl opt">);</span> 
    <span class="hl opt">}</span> 
<span class="hl opt">}).</span><span class="hl kwd">listen</span><span class="hl opt">(</span>puerto<span class="hl opt">,</span> <span class="hl str">'127.0.0.1'</span><span class="hl opt">);</span> 
console<span class="hl opt">.</span><span class="hl kwd">log</span><span class="hl opt">(</span><span class="hl str">'Server running at http://127.0.0.1:'</span><span class="hl opt">+</span>puerto<span class="hl opt">+</span><span class="hl str">'/'</span><span class="hl opt">);</span></code>

<p>En este programa procesamos, no sólo imprimimos, la variable
  <code>req</code>. Es una estructura de datos con un montón de cosas 
  (insertad un console.log si queréis verlo), pero de la que vamos a
  usar solamente el camino. La idea es que el URL lo que describe es
  un recurso, no un fichero, así que nosotros procesamos el URL
  partiéndolo en sus diferentes componentes. Si en el primer
  componente no hay nada, damos la portada; si hay, por ejemplo,
  <code>proc</code>, haríamos otra cosa diferente, y eventualmente si se trata de
  un URL desconocido devolvemos un mensaje diferente.</p>

<p>Adicionalmente, hemos introducido en este programa un puerto que se
  toma de la línea de órdenes. <code>process.argv</code> contiene información
  sobre la línea de órdenes y otras cosas; en el 2º elemento es donde
  está, precisamente, el primer argumento de la línea de órdenes. El
  puerto por omisión será 8080 (lo que se ve en la segunda línea),
  pero si se pasa algún argumento (y es un puerto válido) se usará ese
  valor.</p>


<p>Algunos sitios web como <a href="http://www.heroku.com/">Heroku</a> o
  <a href="http://nodester.com/">Nodester</a> permiten publicar de
  forma gratuita aplicaciones web hechas con node.js. Pueden ser
  bastante útiles para crear prototipos o para hacer pruebas, incluso
  para alojar prácticas de alguna asignatura.</p>


<h2>Para finalizar </h2>



<p>Hay muchas más cosas que se pueden hacer con Node. Por ejemplo, un
  <a href="https://github.com/mixu/nwm">gestor de ventanas</a>. Con
  <a href="http://appjs.org/">appjs</a> puedes construir aplicaciones
  cliente-servidor con su propia ventana, igual que con el más
  veterano <a href="https://github.com/rogerwang/node-webkit">node-webkit</a>.</p>

<p>Si se quiere trabajar principalmente en el
  navegador, <a href="http://jquery.com/">jQuery</a> funciona de forma
  muy similar a node: es un entorno asíncrono para crear aplicaciones  desde el
  navegador fácilmente, sin tener que escribir demasiado código
  JavaScript. Trasladar un programa de node a JavaScript es bastante
  directo, y existen diversidad de ampliaciones (plugins) para jQuery
  que hacen la vida (todavía) más fácil.</p>

<p>Por otro lado, cualquier lenguaje de scripting como Python o Perl
  permite crear también arquitecturas cliente y servidor, sólo que no
  se pueden incluir en el navegador (o usar la experiencia que tenemos
  con el mismo). Sin embargo, especialmente cuando se trate sólo de
  consumir servicios web, pueden ser la opción más adecuada.</p>

<p>En cuanto a recurso para hacer preguntas y obtener respuestas
  interesantes, <a href="http://stackoverflow.com/">StackOverflow</a>
  es un recurso imprescindible. Recuerda que tu karma aumentará
  también cuando contestes preguntas.</p>

<h2> Agradecimientos </h2>



<p>Agradezco a los lectores
  en <a href="http://twitter.com/">Twitter</a>,
  especialmente <a href="http://twitter.com/danielribes">@danielribes</a>,
  sugerencias sobre este material. </p> 

<h2>Bibliografía</h2>



<p>Como recursos adicionales, <a href="https://developer.mozilla.org/en/About_JavaScript">las
	páginas de Javascript en Mozilla.org</a>,
	el <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">estándar
	completo</a>, <a href="http://eloquentjavascript.net/">Eloquent
    Javascript</a> y el <a href="http://geneura.ugr.es/%7Evictor/cursillos/javascript/js_intro.html">curso de Javascript de Víctor Rivas Santos</a>. </p> 

<p>Por
  último, <a href="https://www.amazon.co.uk/dp/0596517742?tag=severawebsite-21&amp;camp=2902&amp;creative=19466&amp;linkCode=as4&amp;creativeASIN=0596517742&amp;adid=0MJ7MPPRP9H7PJ2B5MPB&amp;">Javascript:
    The good parts</a> es un manual bastante completo que menciona
  muchos trucos para trabajar con este lenguaje.</p>

<p>Específicamente de node.js, se puede empezar
    por <a href="http://stackoverflow.com/questions/2353818/how-do-i-get-started-with-node-js">esta
    pregunta en StackOverflow</a>, para seguir
    con <a href="http://www.nodehispano.com/">el 
    sitio de node.js</a> en español, que incluye enlaces
    a <a href="http://www.nodebeginner.org/index-es.html">nodebeginner</a>,
    el libro para principiantes en node.js. La traducción tiene
  algunos errores, pero es
    legible. Finalmente, <a href="http://www.opsou.com/blog/recopilacion-de-tutoriales-sobre-node-js-en-castellano/">Opsou
    nos ofrece una lista de tutoriales en español</a>. Finalmente,
    también hay <a href="https://twitter.com/nodejs_es">una cuenta de
    Twitter (no demasiado activa)</a>. También el libro inserto (o
    cualquier otro recomendado, a esta alturas hay una cantidad
    ingente de bibliografía sobre node.js). </p>

<br clear="all">

<div class="licencia">Este material
  está <a href="http://curso-sobre.berlios.de/gfdles/">disponible bajo
    los términos de la licencia GNU FDL</a>. Si observas algún error
  en la página, te agradeceremos que nos hagas llegar un informe de
  error por correo electrónico (dirección abajo) o, si estás dado de
  alta en la asignatura, a través
  del <a href="http://code.google.com/p/aap-etsiit-ugr/issues/entry">sistema
  de tickets de la misma</a>.  </div>

<div style="float:right">
  <a href="http://validator.w3.org/check?uri=referer"><img src="nodejs_files/valid-html401.png" alt="Valid HTML 4.01 Transitional" height="31" width="88"></a>
</div>
    
<p>    </p><address><a href="mailto:jj%20%28at%29%20merelo.net">Juan
      J. Merelo</a></address> <p></p>
  





</body></html>
